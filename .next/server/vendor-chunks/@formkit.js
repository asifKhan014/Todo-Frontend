"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@formkit";
exports.ids = ["vendor-chunks/@formkit"];
exports.modules = {

/***/ "(ssr)/./node_modules/@formkit/auto-animate/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@formkit/auto-animate/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ autoAnimate),\n/* harmony export */   getTransitionSizes: () => (/* binding */ getTransitionSizes),\n/* harmony export */   vAutoAnimate: () => (/* binding */ vAutoAnimate)\n/* harmony export */ });\n/**\n * A set of all the parents currently being observe. This is the only non weak\n * registry.\n */ const parents = new Set();\n/**\n * Element coordinates that is constantly kept up to date.\n */ const coords = new WeakMap();\n/**\n * Siblings of elements that have been removed from the dom.\n */ const siblings = new WeakMap();\n/**\n * Animations that are currently running.\n */ const animations = new WeakMap();\n/**\n * A map of existing intersection observers used to track element movements.\n */ const intersections = new WeakMap();\n/**\n * Intervals for automatically checking the position of elements occasionally.\n */ const intervals = new WeakMap();\n/**\n * The configuration options for each group of elements.\n */ const options = new WeakMap();\n/**\n * Debounce counters by id, used to debounce calls to update positions.\n */ const debounces = new WeakMap();\n/**\n * All parents that are currently enabled are tracked here.\n */ const enabled = new WeakSet();\n/**\n * The document used to calculate transitions.\n */ let root;\n/**\n * The root’s XY scroll positions.\n */ let scrollX = 0;\nlet scrollY = 0;\n/**\n * Used to sign an element as the target.\n */ const TGT = \"__aa_tgt\";\n/**\n * Used to sign an element as being part of a removal.\n */ const DEL = \"__aa_del\";\n/**\n * Used to sign an element as being \"new\". When an element is removed from the\n * dom, but may cycle back in we can sign it with new to ensure the next time\n * it is recognized we consider it new.\n */ const NEW = \"__aa_new\";\n/**\n * Callback for handling all mutations.\n * @param mutations - A mutation list\n */ const handleMutations = (mutations)=>{\n    const elements = getElements(mutations);\n    // If elements is \"false\" that means this mutation that should be ignored.\n    if (elements) {\n        elements.forEach((el)=>animate(el));\n    }\n};\n/**\n *\n * @param entries - Elements that have been resized.\n */ const handleResizes = (entries)=>{\n    entries.forEach((entry)=>{\n        if (entry.target === root) updateAllPos();\n        if (coords.has(entry.target)) updatePos(entry.target);\n    });\n};\n/**\n * Observe this elements position.\n * @param el - The element to observe the position of.\n */ function observePosition(el) {\n    const oldObserver = intersections.get(el);\n    oldObserver === null || oldObserver === void 0 ? void 0 : oldObserver.disconnect();\n    let rect = coords.get(el);\n    let invocations = 0;\n    const buffer = 5;\n    if (!rect) {\n        rect = getCoords(el);\n        coords.set(el, rect);\n    }\n    const { offsetWidth, offsetHeight } = root;\n    const rootMargins = [\n        rect.top - buffer,\n        offsetWidth - (rect.left + buffer + rect.width),\n        offsetHeight - (rect.top + buffer + rect.height),\n        rect.left - buffer\n    ];\n    const rootMargin = rootMargins.map((px)=>`${-1 * Math.floor(px)}px`).join(\" \");\n    const observer = new IntersectionObserver(()=>{\n        ++invocations > 1 && updatePos(el);\n    }, {\n        root,\n        threshold: 1,\n        rootMargin\n    });\n    observer.observe(el);\n    intersections.set(el, observer);\n}\n/**\n * Update the exact position of a given element.\n * @param el - An element to update the position of.\n */ function updatePos(el) {\n    clearTimeout(debounces.get(el));\n    const optionsOrPlugin = getOptions(el);\n    const delay = isPlugin(optionsOrPlugin) ? 500 : optionsOrPlugin.duration;\n    debounces.set(el, setTimeout(async ()=>{\n        const currentAnimation = animations.get(el);\n        try {\n            await (currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.finished);\n            coords.set(el, getCoords(el));\n            observePosition(el);\n        } catch  {\n        // ignore errors as the `.finished` promise is rejected when animations were cancelled\n        }\n    }, delay));\n}\n/**\n * Updates all positions that are currently being tracked.\n */ function updateAllPos() {\n    clearTimeout(debounces.get(root));\n    debounces.set(root, setTimeout(()=>{\n        parents.forEach((parent)=>forEach(parent, (el)=>lowPriority(()=>updatePos(el))));\n    }, 100));\n}\n/**\n * Its possible for a quick scroll or other fast events to get past the\n * intersection observer, so occasionally we need want \"cold-poll\" for the\n * latests and greatest position. We try to do this in the most non-disruptive\n * fashion possible. First we only do this ever couple seconds, staggard by a\n * random offset.\n * @param el - Element\n */ function poll(el) {\n    setTimeout(()=>{\n        intervals.set(el, setInterval(()=>lowPriority(updatePos.bind(null, el)), 2000));\n    }, Math.round(2000 * Math.random()));\n}\n/**\n * Perform some operation that is non critical at some point.\n * @param callback\n */ function lowPriority(callback) {\n    if (typeof requestIdleCallback === \"function\") {\n        requestIdleCallback(()=>callback());\n    } else {\n        requestAnimationFrame(()=>callback());\n    }\n}\n/**\n * The mutation observer responsible for watching each root element.\n */ let mutations;\n/**\n * A resize observer, responsible for recalculating elements on resize.\n */ let resize;\n/**\n * If this is in a browser, initialize our Web APIs\n */ if (false) {}\n/**\n * Retrieves all the elements that may have been affected by the last mutation\n * including ones that have been removed and are no longer in the DOM.\n * @param mutations - A mutation list.\n * @returns\n */ function getElements(mutations) {\n    const observedNodes = mutations.reduce((nodes, mutation)=>{\n        return [\n            ...nodes,\n            ...Array.from(mutation.addedNodes),\n            ...Array.from(mutation.removedNodes)\n        ];\n    }, []);\n    // Short circuit if _only_ comment nodes are observed\n    const onlyCommentNodesObserved = observedNodes.every((node)=>node.nodeName === \"#comment\");\n    if (onlyCommentNodesObserved) return false;\n    return mutations.reduce((elements, mutation)=>{\n        // Short circuit if we find a purposefully deleted node.\n        if (elements === false) return false;\n        if (mutation.target instanceof Element) {\n            target(mutation.target);\n            if (!elements.has(mutation.target)) {\n                elements.add(mutation.target);\n                for(let i = 0; i < mutation.target.children.length; i++){\n                    const child = mutation.target.children.item(i);\n                    if (!child) continue;\n                    if (DEL in child) {\n                        return false;\n                    }\n                    target(mutation.target, child);\n                    elements.add(child);\n                }\n            }\n            if (mutation.removedNodes.length) {\n                for(let i = 0; i < mutation.removedNodes.length; i++){\n                    const child = mutation.removedNodes[i];\n                    if (DEL in child) {\n                        return false;\n                    }\n                    if (child instanceof Element) {\n                        elements.add(child);\n                        target(mutation.target, child);\n                        siblings.set(child, [\n                            mutation.previousSibling,\n                            mutation.nextSibling\n                        ]);\n                    }\n                }\n            }\n        }\n        return elements;\n    }, new Set());\n}\n/**\n * Assign the target to an element.\n * @param el - The root element\n * @param child\n */ function target(el, child) {\n    if (!child && !(TGT in el)) Object.defineProperty(el, TGT, {\n        value: el\n    });\n    else if (child && !(TGT in child)) Object.defineProperty(child, TGT, {\n        value: el\n    });\n}\n/**\n * Determines what kind of change took place on the given element and then\n * performs the proper animation based on that.\n * @param el - The specific element to animate.\n */ function animate(el) {\n    var _a;\n    const isMounted = el.isConnected;\n    const preExisting = coords.has(el);\n    if (isMounted && siblings.has(el)) siblings.delete(el);\n    if (animations.has(el)) {\n        (_a = animations.get(el)) === null || _a === void 0 ? void 0 : _a.cancel();\n    }\n    if (NEW in el) {\n        add(el);\n    } else if (preExisting && isMounted) {\n        remain(el);\n    } else if (preExisting && !isMounted) {\n        remove(el);\n    } else {\n        add(el);\n    }\n}\n/**\n * Removes all non-digits from a string and casts to a number.\n * @param str - A string containing a pixel value.\n * @returns\n */ function raw(str) {\n    return Number(str.replace(/[^0-9.\\-]/g, \"\"));\n}\n/**\n * Get the scroll offset of elements\n * @param el - Element\n * @returns\n */ function getScrollOffset(el) {\n    let p = el.parentElement;\n    while(p){\n        if (p.scrollLeft || p.scrollTop) {\n            return {\n                x: p.scrollLeft,\n                y: p.scrollTop\n            };\n        }\n        p = p.parentElement;\n    }\n    return {\n        x: 0,\n        y: 0\n    };\n}\n/**\n * Get the coordinates of elements adjusted for scroll position.\n * @param el - Element\n * @returns\n */ function getCoords(el) {\n    const rect = el.getBoundingClientRect();\n    const { x, y } = getScrollOffset(el);\n    return {\n        top: rect.top + y,\n        left: rect.left + x,\n        width: rect.width,\n        height: rect.height\n    };\n}\n/**\n * Returns the width/height that the element should be transitioned between.\n * This takes into account box-sizing.\n * @param el - Element being animated\n * @param oldCoords - Old set of Coordinates coordinates\n * @param newCoords - New set of Coordinates coordinates\n * @returns\n */ function getTransitionSizes(el, oldCoords, newCoords) {\n    let widthFrom = oldCoords.width;\n    let heightFrom = oldCoords.height;\n    let widthTo = newCoords.width;\n    let heightTo = newCoords.height;\n    const styles = getComputedStyle(el);\n    const sizing = styles.getPropertyValue(\"box-sizing\");\n    if (sizing === \"content-box\") {\n        const paddingY = raw(styles.paddingTop) + raw(styles.paddingBottom) + raw(styles.borderTopWidth) + raw(styles.borderBottomWidth);\n        const paddingX = raw(styles.paddingLeft) + raw(styles.paddingRight) + raw(styles.borderRightWidth) + raw(styles.borderLeftWidth);\n        widthFrom -= paddingX;\n        widthTo -= paddingX;\n        heightFrom -= paddingY;\n        heightTo -= paddingY;\n    }\n    return [\n        widthFrom,\n        widthTo,\n        heightFrom,\n        heightTo\n    ].map(Math.round);\n}\n/**\n * Retrieves animation options for the current element.\n * @param el - Element to retrieve options for.\n * @returns\n */ function getOptions(el) {\n    return TGT in el && options.has(el[TGT]) ? options.get(el[TGT]) : {\n        duration: 250,\n        easing: \"ease-in-out\"\n    };\n}\n/**\n * Returns the target of a given animation (generally the parent).\n * @param el - An element to check for a target\n * @returns\n */ function getTarget(el) {\n    if (TGT in el) return el[TGT];\n    return undefined;\n}\n/**\n * Checks if animations are enabled or disabled for a given element.\n * @param el - Any element\n * @returns\n */ function isEnabled(el) {\n    const target = getTarget(el);\n    return target ? enabled.has(target) : false;\n}\n/**\n * Iterate over the children of a given parent.\n * @param parent - A parent element\n * @param callback - A callback\n */ function forEach(parent, ...callbacks) {\n    callbacks.forEach((callback)=>callback(parent, options.has(parent)));\n    for(let i = 0; i < parent.children.length; i++){\n        const child = parent.children.item(i);\n        if (child) {\n            callbacks.forEach((callback)=>callback(child, options.has(child)));\n        }\n    }\n}\n/**\n * Always return tuple to provide consistent interface\n */ function getPluginTuple(pluginReturn) {\n    if (Array.isArray(pluginReturn)) return pluginReturn;\n    return [\n        pluginReturn\n    ];\n}\n/**\n * Determine if config is plugin\n */ function isPlugin(config) {\n    return typeof config === \"function\";\n}\n/**\n * The element in question is remaining in the DOM.\n * @param el - Element to flip\n * @returns\n */ function remain(el) {\n    const oldCoords = coords.get(el);\n    const newCoords = getCoords(el);\n    if (!isEnabled(el)) return coords.set(el, newCoords);\n    let animation;\n    if (!oldCoords) return;\n    const pluginOrOptions = getOptions(el);\n    if (typeof pluginOrOptions !== \"function\") {\n        const deltaX = oldCoords.left - newCoords.left;\n        const deltaY = oldCoords.top - newCoords.top;\n        const [widthFrom, widthTo, heightFrom, heightTo] = getTransitionSizes(el, oldCoords, newCoords);\n        const start = {\n            transform: `translate(${deltaX}px, ${deltaY}px)`\n        };\n        const end = {\n            transform: `translate(0, 0)`\n        };\n        if (widthFrom !== widthTo) {\n            start.width = `${widthFrom}px`;\n            end.width = `${widthTo}px`;\n        }\n        if (heightFrom !== heightTo) {\n            start.height = `${heightFrom}px`;\n            end.height = `${heightTo}px`;\n        }\n        animation = el.animate([\n            start,\n            end\n        ], {\n            duration: pluginOrOptions.duration,\n            easing: pluginOrOptions.easing\n        });\n    } else {\n        const [keyframes] = getPluginTuple(pluginOrOptions(el, \"remain\", oldCoords, newCoords));\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    coords.set(el, newCoords);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Adds the element with a transition.\n * @param el - Animates the element being added.\n */ function add(el) {\n    if (NEW in el) delete el[NEW];\n    const newCoords = getCoords(el);\n    coords.set(el, newCoords);\n    const pluginOrOptions = getOptions(el);\n    if (!isEnabled(el)) return;\n    let animation;\n    if (typeof pluginOrOptions !== \"function\") {\n        animation = el.animate([\n            {\n                transform: \"scale(.98)\",\n                opacity: 0\n            },\n            {\n                transform: \"scale(0.98)\",\n                opacity: 0,\n                offset: 0.5\n            },\n            {\n                transform: \"scale(1)\",\n                opacity: 1\n            }\n        ], {\n            duration: pluginOrOptions.duration * 1.5,\n            easing: \"ease-in\"\n        });\n    } else {\n        const [keyframes] = getPluginTuple(pluginOrOptions(el, \"add\", newCoords));\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", updatePos.bind(null, el));\n}\n/**\n * Clean up after removing an element from the dom.\n * @param el - Element being removed\n * @param styles - Optional styles that should be removed from the element.\n */ function cleanUp(el, styles) {\n    var _a;\n    el.remove();\n    coords.delete(el);\n    siblings.delete(el);\n    animations.delete(el);\n    (_a = intersections.get(el)) === null || _a === void 0 ? void 0 : _a.disconnect();\n    setTimeout(()=>{\n        if (DEL in el) delete el[DEL];\n        Object.defineProperty(el, NEW, {\n            value: true,\n            configurable: true\n        });\n        if (styles && el instanceof HTMLElement) {\n            for(const style in styles){\n                el.style[style] = \"\";\n            }\n        }\n    }, 0);\n}\n/**\n * Animates the removal of an element.\n * @param el - Element to remove\n */ function remove(el) {\n    var _a;\n    if (!siblings.has(el) || !coords.has(el)) return;\n    const [prev, next] = siblings.get(el);\n    Object.defineProperty(el, DEL, {\n        value: true,\n        configurable: true\n    });\n    const finalX = window.scrollX;\n    const finalY = window.scrollY;\n    if (next && next.parentNode && next.parentNode instanceof Element) {\n        next.parentNode.insertBefore(el, next);\n    } else if (prev && prev.parentNode) {\n        prev.parentNode.appendChild(el);\n    } else {\n        (_a = getTarget(el)) === null || _a === void 0 ? void 0 : _a.appendChild(el);\n    }\n    if (!isEnabled(el)) return cleanUp(el);\n    const [top, left, width, height] = deletePosition(el);\n    const optionsOrPlugin = getOptions(el);\n    const oldCoords = coords.get(el);\n    if (finalX !== scrollX || finalY !== scrollY) {\n        adjustScroll(el, finalX, finalY, optionsOrPlugin);\n    }\n    let animation;\n    let styleReset = {\n        position: \"absolute\",\n        top: `${top}px`,\n        left: `${left}px`,\n        width: `${width}px`,\n        height: `${height}px`,\n        margin: \"0\",\n        pointerEvents: \"none\",\n        transformOrigin: \"center\",\n        zIndex: \"100\"\n    };\n    if (!isPlugin(optionsOrPlugin)) {\n        Object.assign(el.style, styleReset);\n        animation = el.animate([\n            {\n                transform: \"scale(1)\",\n                opacity: 1\n            },\n            {\n                transform: \"scale(.98)\",\n                opacity: 0\n            }\n        ], {\n            duration: optionsOrPlugin.duration,\n            easing: \"ease-out\"\n        });\n    } else {\n        const [keyframes, options] = getPluginTuple(optionsOrPlugin(el, \"remove\", oldCoords));\n        if ((options === null || options === void 0 ? void 0 : options.styleReset) !== false) {\n            styleReset = (options === null || options === void 0 ? void 0 : options.styleReset) || styleReset;\n            Object.assign(el.style, styleReset);\n        }\n        animation = new Animation(keyframes);\n        animation.play();\n    }\n    animations.set(el, animation);\n    animation.addEventListener(\"finish\", cleanUp.bind(null, el, styleReset));\n}\n/**\n * If the element being removed is at the very bottom of the page, and the\n * the page was scrolled into a space being \"made available\" by the element\n * that was removed, the page scroll will have jumped up some amount. We need\n * to offset the jump by the amount that the page was \"automatically\" scrolled\n * up. We can do this by comparing the scroll position before and after the\n * element was removed, and then offsetting by that amount.\n *\n * @param el - The element being deleted\n * @param finalX - The final X scroll position\n * @param finalY - The final Y scroll position\n * @param optionsOrPlugin - The options or plugin\n * @returns\n */ function adjustScroll(el, finalX, finalY, optionsOrPlugin) {\n    const scrollDeltaX = scrollX - finalX;\n    const scrollDeltaY = scrollY - finalY;\n    const scrollBefore = document.documentElement.style.scrollBehavior;\n    const scrollBehavior = getComputedStyle(root).scrollBehavior;\n    if (scrollBehavior === \"smooth\") {\n        document.documentElement.style.scrollBehavior = \"auto\";\n    }\n    window.scrollTo(window.scrollX + scrollDeltaX, window.scrollY + scrollDeltaY);\n    if (!el.parentElement) return;\n    const parent = el.parentElement;\n    let lastHeight = parent.clientHeight;\n    let lastWidth = parent.clientWidth;\n    const startScroll = performance.now();\n    // Here we use a manual scroll animation to keep the element using the same\n    // easing and timing as the parent’s scroll animation.\n    function smoothScroll() {\n        requestAnimationFrame(()=>{\n            if (!isPlugin(optionsOrPlugin)) {\n                const deltaY = lastHeight - parent.clientHeight;\n                const deltaX = lastWidth - parent.clientWidth;\n                if (startScroll + optionsOrPlugin.duration > performance.now()) {\n                    window.scrollTo({\n                        left: window.scrollX - deltaX,\n                        top: window.scrollY - deltaY\n                    });\n                    lastHeight = parent.clientHeight;\n                    lastWidth = parent.clientWidth;\n                    smoothScroll();\n                } else {\n                    document.documentElement.style.scrollBehavior = scrollBefore;\n                }\n            }\n        });\n    }\n    smoothScroll();\n}\n/**\n * Determines the position of the element being removed.\n * @param el - The element being deleted\n * @returns\n */ function deletePosition(el) {\n    const oldCoords = coords.get(el);\n    const [width, , height] = getTransitionSizes(el, oldCoords, getCoords(el));\n    let offsetParent = el.parentElement;\n    while(offsetParent && (getComputedStyle(offsetParent).position === \"static\" || offsetParent instanceof HTMLBodyElement)){\n        offsetParent = offsetParent.parentElement;\n    }\n    if (!offsetParent) offsetParent = document.body;\n    const parentStyles = getComputedStyle(offsetParent);\n    const parentCoords = coords.get(offsetParent) || getCoords(offsetParent);\n    const top = Math.round(oldCoords.top - parentCoords.top) - raw(parentStyles.borderTopWidth);\n    const left = Math.round(oldCoords.left - parentCoords.left) - raw(parentStyles.borderLeftWidth);\n    return [\n        top,\n        left,\n        width,\n        height\n    ];\n}\n/**\n * A function that automatically adds animation effects to itself and its\n * immediate children. Specifically it adds effects for adding, moving, and\n * removing DOM elements.\n * @param el - A parent element to add animations to.\n * @param options - An optional object of options.\n */ function autoAnimate(el, config = {}) {\n    if (mutations && resize) {\n        const mediaQuery = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\n        const isDisabledDueToReduceMotion = mediaQuery.matches && !isPlugin(config) && !config.disrespectUserMotionPreference;\n        if (!isDisabledDueToReduceMotion) {\n            enabled.add(el);\n            if (getComputedStyle(el).position === \"static\") {\n                Object.assign(el.style, {\n                    position: \"relative\"\n                });\n            }\n            forEach(el, updatePos, poll, (element)=>resize === null || resize === void 0 ? void 0 : resize.observe(element));\n            if (isPlugin(config)) {\n                options.set(el, config);\n            } else {\n                options.set(el, {\n                    duration: 250,\n                    easing: \"ease-in-out\",\n                    ...config\n                });\n            }\n            mutations.observe(el, {\n                childList: true\n            });\n            parents.add(el);\n        }\n    }\n    return Object.freeze({\n        parent: el,\n        enable: ()=>{\n            enabled.add(el);\n        },\n        disable: ()=>{\n            enabled.delete(el);\n        },\n        isEnabled: ()=>enabled.has(el)\n    });\n}\n/**\n * The vue directive.\n */ const vAutoAnimate = {\n    mounted: (el, binding)=>{\n        autoAnimate(el, binding.value || {});\n    },\n    // ignore ssr see #96:\n    getSSRProps: ()=>({})\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvYXV0by1hbmltYXRlL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxNQUFNQSxVQUFVLElBQUlDO0FBQ3BCOztDQUVDLEdBQ0QsTUFBTUMsU0FBUyxJQUFJQztBQUNuQjs7Q0FFQyxHQUNELE1BQU1DLFdBQVcsSUFBSUQ7QUFDckI7O0NBRUMsR0FDRCxNQUFNRSxhQUFhLElBQUlGO0FBQ3ZCOztDQUVDLEdBQ0QsTUFBTUcsZ0JBQWdCLElBQUlIO0FBQzFCOztDQUVDLEdBQ0QsTUFBTUksWUFBWSxJQUFJSjtBQUN0Qjs7Q0FFQyxHQUNELE1BQU1LLFVBQVUsSUFBSUw7QUFDcEI7O0NBRUMsR0FDRCxNQUFNTSxZQUFZLElBQUlOO0FBQ3RCOztDQUVDLEdBQ0QsTUFBTU8sVUFBVSxJQUFJQztBQUNwQjs7Q0FFQyxHQUNELElBQUlDO0FBQ0o7O0NBRUMsR0FDRCxJQUFJQyxVQUFVO0FBQ2QsSUFBSUMsVUFBVTtBQUNkOztDQUVDLEdBQ0QsTUFBTUMsTUFBTTtBQUNaOztDQUVDLEdBQ0QsTUFBTUMsTUFBTTtBQUNaOzs7O0NBSUMsR0FDRCxNQUFNQyxNQUFNO0FBQ1o7OztDQUdDLEdBQ0QsTUFBTUMsa0JBQWtCLENBQUNDO0lBQ3JCLE1BQU1DLFdBQVdDLFlBQVlGO0lBQzdCLDBFQUEwRTtJQUMxRSxJQUFJQyxVQUFVO1FBQ1ZBLFNBQVNFLE9BQU8sQ0FBQyxDQUFDQyxLQUFPQyxRQUFRRDtJQUNyQztBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUUsZ0JBQWdCLENBQUNDO0lBQ25CQSxRQUFRSixPQUFPLENBQUMsQ0FBQ0s7UUFDYixJQUFJQSxNQUFNQyxNQUFNLEtBQUtoQixNQUNqQmlCO1FBQ0osSUFBSTNCLE9BQU80QixHQUFHLENBQUNILE1BQU1DLE1BQU0sR0FDdkJHLFVBQVVKLE1BQU1DLE1BQU07SUFDOUI7QUFDSjtBQUNBOzs7Q0FHQyxHQUNELFNBQVNJLGdCQUFnQlQs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QUFPLEVBQUM7QUFDekI7QUFFb0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90b2RvLy4vbm9kZV9tb2R1bGVzL0Bmb3Jta2l0L2F1dG8tYW5pbWF0ZS9pbmRleC5tanM/YThkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgc2V0IG9mIGFsbCB0aGUgcGFyZW50cyBjdXJyZW50bHkgYmVpbmcgb2JzZXJ2ZS4gVGhpcyBpcyB0aGUgb25seSBub24gd2Vha1xuICogcmVnaXN0cnkuXG4gKi9cbmNvbnN0IHBhcmVudHMgPSBuZXcgU2V0KCk7XG4vKipcbiAqIEVsZW1lbnQgY29vcmRpbmF0ZXMgdGhhdCBpcyBjb25zdGFudGx5IGtlcHQgdXAgdG8gZGF0ZS5cbiAqL1xuY29uc3QgY29vcmRzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogU2libGluZ3Mgb2YgZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBkb20uXG4gKi9cbmNvbnN0IHNpYmxpbmdzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQW5pbWF0aW9ucyB0aGF0IGFyZSBjdXJyZW50bHkgcnVubmluZy5cbiAqL1xuY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEEgbWFwIG9mIGV4aXN0aW5nIGludGVyc2VjdGlvbiBvYnNlcnZlcnMgdXNlZCB0byB0cmFjayBlbGVtZW50IG1vdmVtZW50cy5cbiAqL1xuY29uc3QgaW50ZXJzZWN0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEludGVydmFscyBmb3IgYXV0b21hdGljYWxseSBjaGVja2luZyB0aGUgcG9zaXRpb24gb2YgZWxlbWVudHMgb2NjYXNpb25hbGx5LlxuICovXG5jb25zdCBpbnRlcnZhbHMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBlYWNoIGdyb3VwIG9mIGVsZW1lbnRzLlxuICovXG5jb25zdCBvcHRpb25zID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogRGVib3VuY2UgY291bnRlcnMgYnkgaWQsIHVzZWQgdG8gZGVib3VuY2UgY2FsbHMgdG8gdXBkYXRlIHBvc2l0aW9ucy5cbiAqL1xuY29uc3QgZGVib3VuY2VzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogQWxsIHBhcmVudHMgdGhhdCBhcmUgY3VycmVudGx5IGVuYWJsZWQgYXJlIHRyYWNrZWQgaGVyZS5cbiAqL1xuY29uc3QgZW5hYmxlZCA9IG5ldyBXZWFrU2V0KCk7XG4vKipcbiAqIFRoZSBkb2N1bWVudCB1c2VkIHRvIGNhbGN1bGF0ZSB0cmFuc2l0aW9ucy5cbiAqL1xubGV0IHJvb3Q7XG4vKipcbiAqIFRoZSByb2904oCZcyBYWSBzY3JvbGwgcG9zaXRpb25zLlxuICovXG5sZXQgc2Nyb2xsWCA9IDA7XG5sZXQgc2Nyb2xsWSA9IDA7XG4vKipcbiAqIFVzZWQgdG8gc2lnbiBhbiBlbGVtZW50IGFzIHRoZSB0YXJnZXQuXG4gKi9cbmNvbnN0IFRHVCA9IFwiX19hYV90Z3RcIjtcbi8qKlxuICogVXNlZCB0byBzaWduIGFuIGVsZW1lbnQgYXMgYmVpbmcgcGFydCBvZiBhIHJlbW92YWwuXG4gKi9cbmNvbnN0IERFTCA9IFwiX19hYV9kZWxcIjtcbi8qKlxuICogVXNlZCB0byBzaWduIGFuIGVsZW1lbnQgYXMgYmVpbmcgXCJuZXdcIi4gV2hlbiBhbiBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGVcbiAqIGRvbSwgYnV0IG1heSBjeWNsZSBiYWNrIGluIHdlIGNhbiBzaWduIGl0IHdpdGggbmV3IHRvIGVuc3VyZSB0aGUgbmV4dCB0aW1lXG4gKiBpdCBpcyByZWNvZ25pemVkIHdlIGNvbnNpZGVyIGl0IG5ldy5cbiAqL1xuY29uc3QgTkVXID0gXCJfX2FhX25ld1wiO1xuLyoqXG4gKiBDYWxsYmFjayBmb3IgaGFuZGxpbmcgYWxsIG11dGF0aW9ucy5cbiAqIEBwYXJhbSBtdXRhdGlvbnMgLSBBIG11dGF0aW9uIGxpc3RcbiAqL1xuY29uc3QgaGFuZGxlTXV0YXRpb25zID0gKG11dGF0aW9ucykgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gZ2V0RWxlbWVudHMobXV0YXRpb25zKTtcbiAgICAvLyBJZiBlbGVtZW50cyBpcyBcImZhbHNlXCIgdGhhdCBtZWFucyB0aGlzIG11dGF0aW9uIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiBhbmltYXRlKGVsKSk7XG4gICAgfVxufTtcbi8qKlxuICpcbiAqIEBwYXJhbSBlbnRyaWVzIC0gRWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gcmVzaXplZC5cbiAqL1xuY29uc3QgaGFuZGxlUmVzaXplcyA9IChlbnRyaWVzKSA9PiB7XG4gICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICBpZiAoZW50cnkudGFyZ2V0ID09PSByb290KVxuICAgICAgICAgICAgdXBkYXRlQWxsUG9zKCk7XG4gICAgICAgIGlmIChjb29yZHMuaGFzKGVudHJ5LnRhcmdldCkpXG4gICAgICAgICAgICB1cGRhdGVQb3MoZW50cnkudGFyZ2V0KTtcbiAgICB9KTtcbn07XG4vKipcbiAqIE9ic2VydmUgdGhpcyBlbGVtZW50cyBwb3NpdGlvbi5cbiAqIEBwYXJhbSBlbCAtIFRoZSBlbGVtZW50IHRvIG9ic2VydmUgdGhlIHBvc2l0aW9uIG9mLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlUG9zaXRpb24oZWwpIHtcbiAgICBjb25zdCBvbGRPYnNlcnZlciA9IGludGVyc2VjdGlvbnMuZ2V0KGVsKTtcbiAgICBvbGRPYnNlcnZlciA9PT0gbnVsbCB8fCBvbGRPYnNlcnZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIGxldCByZWN0ID0gY29vcmRzLmdldChlbCk7XG4gICAgbGV0IGludm9jYXRpb25zID0gMDtcbiAgICBjb25zdCBidWZmZXIgPSA1O1xuICAgIGlmICghcmVjdCkge1xuICAgICAgICByZWN0ID0gZ2V0Q29vcmRzKGVsKTtcbiAgICAgICAgY29vcmRzLnNldChlbCwgcmVjdCk7XG4gICAgfVxuICAgIGNvbnN0IHsgb2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCB9ID0gcm9vdDtcbiAgICBjb25zdCByb290TWFyZ2lucyA9IFtcbiAgICAgICAgcmVjdC50b3AgLSBidWZmZXIsXG4gICAgICAgIG9mZnNldFdpZHRoIC0gKHJlY3QubGVmdCArIGJ1ZmZlciArIHJlY3Qud2lkdGgpLFxuICAgICAgICBvZmZzZXRIZWlnaHQgLSAocmVjdC50b3AgKyBidWZmZXIgKyByZWN0LmhlaWdodCksXG4gICAgICAgIHJlY3QubGVmdCAtIGJ1ZmZlcixcbiAgICBdO1xuICAgIGNvbnN0IHJvb3RNYXJnaW4gPSByb290TWFyZ2luc1xuICAgICAgICAubWFwKChweCkgPT4gYCR7LTEgKiBNYXRoLmZsb29yKHB4KX1weGApXG4gICAgICAgIC5qb2luKFwiIFwiKTtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICsraW52b2NhdGlvbnMgPiAxICYmIHVwZGF0ZVBvcyhlbCk7XG4gICAgfSwge1xuICAgICAgICByb290LFxuICAgICAgICB0aHJlc2hvbGQ6IDEsXG4gICAgICAgIHJvb3RNYXJnaW4sXG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbCk7XG4gICAgaW50ZXJzZWN0aW9ucy5zZXQoZWwsIG9ic2VydmVyKTtcbn1cbi8qKlxuICogVXBkYXRlIHRoZSBleGFjdCBwb3NpdGlvbiBvZiBhIGdpdmVuIGVsZW1lbnQuXG4gKiBAcGFyYW0gZWwgLSBBbiBlbGVtZW50IHRvIHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVBvcyhlbCkge1xuICAgIGNsZWFyVGltZW91dChkZWJvdW5jZXMuZ2V0KGVsKSk7XG4gICAgY29uc3Qgb3B0aW9uc09yUGx1Z2luID0gZ2V0T3B0aW9ucyhlbCk7XG4gICAgY29uc3QgZGVsYXkgPSBpc1BsdWdpbihvcHRpb25zT3JQbHVnaW4pID8gNTAwIDogb3B0aW9uc09yUGx1Z2luLmR1cmF0aW9uO1xuICAgIGRlYm91bmNlcy5zZXQoZWwsIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0aW9ucy5nZXQoZWwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgKGN1cnJlbnRBbmltYXRpb24gPT09IG51bGwgfHwgY3VycmVudEFuaW1hdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEFuaW1hdGlvbi5maW5pc2hlZCk7XG4gICAgICAgICAgICBjb29yZHMuc2V0KGVsLCBnZXRDb29yZHMoZWwpKTtcbiAgICAgICAgICAgIG9ic2VydmVQb3NpdGlvbihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgLy8gaWdub3JlIGVycm9ycyBhcyB0aGUgYC5maW5pc2hlZGAgcHJvbWlzZSBpcyByZWplY3RlZCB3aGVuIGFuaW1hdGlvbnMgd2VyZSBjYW5jZWxsZWRcbiAgICAgICAgfVxuICAgIH0sIGRlbGF5KSk7XG59XG4vKipcbiAqIFVwZGF0ZXMgYWxsIHBvc2l0aW9ucyB0aGF0IGFyZSBjdXJyZW50bHkgYmVpbmcgdHJhY2tlZC5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlQWxsUG9zKCkge1xuICAgIGNsZWFyVGltZW91dChkZWJvdW5jZXMuZ2V0KHJvb3QpKTtcbiAgICBkZWJvdW5jZXMuc2V0KHJvb3QsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBwYXJlbnRzLmZvckVhY2goKHBhcmVudCkgPT4gZm9yRWFjaChwYXJlbnQsIChlbCkgPT4gbG93UHJpb3JpdHkoKCkgPT4gdXBkYXRlUG9zKGVsKSkpKTtcbiAgICB9LCAxMDApKTtcbn1cbi8qKlxuICogSXRzIHBvc3NpYmxlIGZvciBhIHF1aWNrIHNjcm9sbCBvciBvdGhlciBmYXN0IGV2ZW50cyB0byBnZXQgcGFzdCB0aGVcbiAqIGludGVyc2VjdGlvbiBvYnNlcnZlciwgc28gb2NjYXNpb25hbGx5IHdlIG5lZWQgd2FudCBcImNvbGQtcG9sbFwiIGZvciB0aGVcbiAqIGxhdGVzdHMgYW5kIGdyZWF0ZXN0IHBvc2l0aW9uLiBXZSB0cnkgdG8gZG8gdGhpcyBpbiB0aGUgbW9zdCBub24tZGlzcnVwdGl2ZVxuICogZmFzaGlvbiBwb3NzaWJsZS4gRmlyc3Qgd2Ugb25seSBkbyB0aGlzIGV2ZXIgY291cGxlIHNlY29uZHMsIHN0YWdnYXJkIGJ5IGFcbiAqIHJhbmRvbSBvZmZzZXQuXG4gKiBAcGFyYW0gZWwgLSBFbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHBvbGwoZWwpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaW50ZXJ2YWxzLnNldChlbCwgc2V0SW50ZXJ2YWwoKCkgPT4gbG93UHJpb3JpdHkodXBkYXRlUG9zLmJpbmQobnVsbCwgZWwpKSwgMjAwMCkpO1xuICAgIH0sIE1hdGgucm91bmQoMjAwMCAqIE1hdGgucmFuZG9tKCkpKTtcbn1cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiB0aGF0IGlzIG5vbiBjcml0aWNhbCBhdCBzb21lIHBvaW50LlxuICogQHBhcmFtIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGxvd1ByaW9yaXR5KGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiBjYWxsYmFjaygpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBjYWxsYmFjaygpKTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBtdXRhdGlvbiBvYnNlcnZlciByZXNwb25zaWJsZSBmb3Igd2F0Y2hpbmcgZWFjaCByb290IGVsZW1lbnQuXG4gKi9cbmxldCBtdXRhdGlvbnM7XG4vKipcbiAqIEEgcmVzaXplIG9ic2VydmVyLCByZXNwb25zaWJsZSBmb3IgcmVjYWxjdWxhdGluZyBlbGVtZW50cyBvbiByZXNpemUuXG4gKi9cbmxldCByZXNpemU7XG4vKipcbiAqIElmIHRoaXMgaXMgaW4gYSBicm93c2VyLCBpbml0aWFsaXplIG91ciBXZWIgQVBJc1xuICovXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgbXV0YXRpb25zID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoaGFuZGxlTXV0YXRpb25zKTtcbiAgICByZXNpemUgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoaGFuZGxlUmVzaXplcyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgICBzY3JvbGxZID0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgIHNjcm9sbFggPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICB9KTtcbiAgICByZXNpemUub2JzZXJ2ZShyb290KTtcbn1cbi8qKlxuICogUmV0cmlldmVzIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBtYXkgaGF2ZSBiZWVuIGFmZmVjdGVkIGJ5IHRoZSBsYXN0IG11dGF0aW9uXG4gKiBpbmNsdWRpbmcgb25lcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGFuZCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBET00uXG4gKiBAcGFyYW0gbXV0YXRpb25zIC0gQSBtdXRhdGlvbiBsaXN0LlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0RWxlbWVudHMobXV0YXRpb25zKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZWROb2RlcyA9IG11dGF0aW9ucy5yZWR1Y2UoKG5vZGVzLCBtdXRhdGlvbikgPT4ge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4ubm9kZXMsXG4gICAgICAgICAgICAuLi5BcnJheS5mcm9tKG11dGF0aW9uLmFkZGVkTm9kZXMpLFxuICAgICAgICAgICAgLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5yZW1vdmVkTm9kZXMpLFxuICAgICAgICBdO1xuICAgIH0sIFtdKTtcbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIF9vbmx5XyBjb21tZW50IG5vZGVzIGFyZSBvYnNlcnZlZFxuICAgIGNvbnN0IG9ubHlDb21tZW50Tm9kZXNPYnNlcnZlZCA9IG9ic2VydmVkTm9kZXMuZXZlcnkoKG5vZGUpID0+IG5vZGUubm9kZU5hbWUgPT09IFwiI2NvbW1lbnRcIik7XG4gICAgaWYgKG9ubHlDb21tZW50Tm9kZXNPYnNlcnZlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBtdXRhdGlvbnMucmVkdWNlKChlbGVtZW50cywgbXV0YXRpb24pID0+IHtcbiAgICAgICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBmaW5kIGEgcHVycG9zZWZ1bGx5IGRlbGV0ZWQgbm9kZS5cbiAgICAgICAgaWYgKGVsZW1lbnRzID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG11dGF0aW9uLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRhcmdldChtdXRhdGlvbi50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50cy5oYXMobXV0YXRpb24udGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzLmFkZChtdXRhdGlvbi50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24udGFyZ2V0LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbXV0YXRpb24udGFyZ2V0LmNoaWxkcmVuLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKERFTCBpbiBjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldChtdXRhdGlvbi50YXJnZXQsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMuYWRkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXV0YXRpb24ucmVtb3ZlZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoREVMIGluIGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMuYWRkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldChtdXRhdGlvbi50YXJnZXQsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNldChjaGlsZCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uLnByZXZpb3VzU2libGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbi5uZXh0U2libGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LCBuZXcgU2V0KCkpO1xufVxuLyoqXG4gKiBBc3NpZ24gdGhlIHRhcmdldCB0byBhbiBlbGVtZW50LlxuICogQHBhcmFtIGVsIC0gVGhlIHJvb3QgZWxlbWVudFxuICogQHBhcmFtIGNoaWxkXG4gKi9cbmZ1bmN0aW9uIHRhcmdldChlbCwgY2hpbGQpIHtcbiAgICBpZiAoIWNoaWxkICYmICEoVEdUIGluIGVsKSlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsLCBUR1QsIHsgdmFsdWU6IGVsIH0pO1xuICAgIGVsc2UgaWYgKGNoaWxkICYmICEoVEdUIGluIGNoaWxkKSlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBUR1QsIHsgdmFsdWU6IGVsIH0pO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoYXQga2luZCBvZiBjaGFuZ2UgdG9vayBwbGFjZSBvbiB0aGUgZ2l2ZW4gZWxlbWVudCBhbmQgdGhlblxuICogcGVyZm9ybXMgdGhlIHByb3BlciBhbmltYXRpb24gYmFzZWQgb24gdGhhdC5cbiAqIEBwYXJhbSBlbCAtIFRoZSBzcGVjaWZpYyBlbGVtZW50IHRvIGFuaW1hdGUuXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGUoZWwpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgaXNNb3VudGVkID0gZWwuaXNDb25uZWN0ZWQ7XG4gICAgY29uc3QgcHJlRXhpc3RpbmcgPSBjb29yZHMuaGFzKGVsKTtcbiAgICBpZiAoaXNNb3VudGVkICYmIHNpYmxpbmdzLmhhcyhlbCkpXG4gICAgICAgIHNpYmxpbmdzLmRlbGV0ZShlbCk7XG4gICAgaWYgKGFuaW1hdGlvbnMuaGFzKGVsKSkge1xuICAgICAgICAoX2EgPSBhbmltYXRpb25zLmdldChlbCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWwoKTtcbiAgICB9XG4gICAgaWYgKE5FVyBpbiBlbCkge1xuICAgICAgICBhZGQoZWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcmVFeGlzdGluZyAmJiBpc01vdW50ZWQpIHtcbiAgICAgICAgcmVtYWluKGVsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJlRXhpc3RpbmcgJiYgIWlzTW91bnRlZCkge1xuICAgICAgICByZW1vdmUoZWwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWRkKGVsKTtcbiAgICB9XG59XG4vKipcbiAqIFJlbW92ZXMgYWxsIG5vbi1kaWdpdHMgZnJvbSBhIHN0cmluZyBhbmQgY2FzdHMgdG8gYSBudW1iZXIuXG4gKiBAcGFyYW0gc3RyIC0gQSBzdHJpbmcgY29udGFpbmluZyBhIHBpeGVsIHZhbHVlLlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gcmF3KHN0cikge1xuICAgIHJldHVybiBOdW1iZXIoc3RyLnJlcGxhY2UoL1teMC05LlxcLV0vZywgXCJcIikpO1xufVxuLyoqXG4gKiBHZXQgdGhlIHNjcm9sbCBvZmZzZXQgb2YgZWxlbWVudHNcbiAqIEBwYXJhbSBlbCAtIEVsZW1lbnRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbE9mZnNldChlbCkge1xuICAgIGxldCBwID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgICBpZiAocC5zY3JvbGxMZWZ0IHx8IHAuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBwLnNjcm9sbExlZnQsIHk6IHAuc2Nyb2xsVG9wIH07XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xufVxuLyoqXG4gKiBHZXQgdGhlIGNvb3JkaW5hdGVzIG9mIGVsZW1lbnRzIGFkanVzdGVkIGZvciBzY3JvbGwgcG9zaXRpb24uXG4gKiBAcGFyYW0gZWwgLSBFbGVtZW50XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRDb29yZHMoZWwpIHtcbiAgICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRTY3JvbGxPZmZzZXQoZWwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcmVjdC50b3AgKyB5LFxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyB4LFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB3aWR0aC9oZWlnaHQgdGhhdCB0aGUgZWxlbWVudCBzaG91bGQgYmUgdHJhbnNpdGlvbmVkIGJldHdlZW4uXG4gKiBUaGlzIHRha2VzIGludG8gYWNjb3VudCBib3gtc2l6aW5nLlxuICogQHBhcmFtIGVsIC0gRWxlbWVudCBiZWluZyBhbmltYXRlZFxuICogQHBhcmFtIG9sZENvb3JkcyAtIE9sZCBzZXQgb2YgQ29vcmRpbmF0ZXMgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSBuZXdDb29yZHMgLSBOZXcgc2V0IG9mIENvb3JkaW5hdGVzIGNvb3JkaW5hdGVzXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uU2l6ZXMoZWwsIG9sZENvb3JkcywgbmV3Q29vcmRzKSB7XG4gICAgbGV0IHdpZHRoRnJvbSA9IG9sZENvb3Jkcy53aWR0aDtcbiAgICBsZXQgaGVpZ2h0RnJvbSA9IG9sZENvb3Jkcy5oZWlnaHQ7XG4gICAgbGV0IHdpZHRoVG8gPSBuZXdDb29yZHMud2lkdGg7XG4gICAgbGV0IGhlaWdodFRvID0gbmV3Q29vcmRzLmhlaWdodDtcbiAgICBjb25zdCBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICBjb25zdCBzaXppbmcgPSBzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZShcImJveC1zaXppbmdcIik7XG4gICAgaWYgKHNpemluZyA9PT0gXCJjb250ZW50LWJveFwiKSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdZID0gcmF3KHN0eWxlcy5wYWRkaW5nVG9wKSArXG4gICAgICAgICAgICByYXcoc3R5bGVzLnBhZGRpbmdCb3R0b20pICtcbiAgICAgICAgICAgIHJhdyhzdHlsZXMuYm9yZGVyVG9wV2lkdGgpICtcbiAgICAgICAgICAgIHJhdyhzdHlsZXMuYm9yZGVyQm90dG9tV2lkdGgpO1xuICAgICAgICBjb25zdCBwYWRkaW5nWCA9IHJhdyhzdHlsZXMucGFkZGluZ0xlZnQpICtcbiAgICAgICAgICAgIHJhdyhzdHlsZXMucGFkZGluZ1JpZ2h0KSArXG4gICAgICAgICAgICByYXcoc3R5bGVzLmJvcmRlclJpZ2h0V2lkdGgpICtcbiAgICAgICAgICAgIHJhdyhzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcbiAgICAgICAgd2lkdGhGcm9tIC09IHBhZGRpbmdYO1xuICAgICAgICB3aWR0aFRvIC09IHBhZGRpbmdYO1xuICAgICAgICBoZWlnaHRGcm9tIC09IHBhZGRpbmdZO1xuICAgICAgICBoZWlnaHRUbyAtPSBwYWRkaW5nWTtcbiAgICB9XG4gICAgcmV0dXJuIFt3aWR0aEZyb20sIHdpZHRoVG8sIGhlaWdodEZyb20sIGhlaWdodFRvXS5tYXAoTWF0aC5yb3VuZCk7XG59XG4vKipcbiAqIFJldHJpZXZlcyBhbmltYXRpb24gb3B0aW9ucyBmb3IgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAqIEBwYXJhbSBlbCAtIEVsZW1lbnQgdG8gcmV0cmlldmUgb3B0aW9ucyBmb3IuXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRPcHRpb25zKGVsKSB7XG4gICAgcmV0dXJuIFRHVCBpbiBlbCAmJiBvcHRpb25zLmhhcyhlbFtUR1RdKVxuICAgICAgICA/IG9wdGlvbnMuZ2V0KGVsW1RHVF0pXG4gICAgICAgIDogeyBkdXJhdGlvbjogMjUwLCBlYXNpbmc6IFwiZWFzZS1pbi1vdXRcIiB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0YXJnZXQgb2YgYSBnaXZlbiBhbmltYXRpb24gKGdlbmVyYWxseSB0aGUgcGFyZW50KS5cbiAqIEBwYXJhbSBlbCAtIEFuIGVsZW1lbnQgdG8gY2hlY2sgZm9yIGEgdGFyZ2V0XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRUYXJnZXQoZWwpIHtcbiAgICBpZiAoVEdUIGluIGVsKVxuICAgICAgICByZXR1cm4gZWxbVEdUXTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYW5pbWF0aW9ucyBhcmUgZW5hYmxlZCBvciBkaXNhYmxlZCBmb3IgYSBnaXZlbiBlbGVtZW50LlxuICogQHBhcmFtIGVsIC0gQW55IGVsZW1lbnRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlzRW5hYmxlZChlbCkge1xuICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldChlbCk7XG4gICAgcmV0dXJuIHRhcmdldCA/IGVuYWJsZWQuaGFzKHRhcmdldCkgOiBmYWxzZTtcbn1cbi8qKlxuICogSXRlcmF0ZSBvdmVyIHRoZSBjaGlsZHJlbiBvZiBhIGdpdmVuIHBhcmVudC5cbiAqIEBwYXJhbSBwYXJlbnQgLSBBIHBhcmVudCBlbGVtZW50XG4gKiBAcGFyYW0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gocGFyZW50LCAuLi5jYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKHBhcmVudCwgb3B0aW9ucy5oYXMocGFyZW50KSkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuLml0ZW0oaSk7XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayhjaGlsZCwgb3B0aW9ucy5oYXMoY2hpbGQpKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFsd2F5cyByZXR1cm4gdHVwbGUgdG8gcHJvdmlkZSBjb25zaXN0ZW50IGludGVyZmFjZVxuICovXG5mdW5jdGlvbiBnZXRQbHVnaW5UdXBsZShwbHVnaW5SZXR1cm4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW5SZXR1cm4pKVxuICAgICAgICByZXR1cm4gcGx1Z2luUmV0dXJuO1xuICAgIHJldHVybiBbcGx1Z2luUmV0dXJuXTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGNvbmZpZyBpcyBwbHVnaW5cbiAqL1xuZnVuY3Rpb24gaXNQbHVnaW4oY29uZmlnKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIjtcbn1cbi8qKlxuICogVGhlIGVsZW1lbnQgaW4gcXVlc3Rpb24gaXMgcmVtYWluaW5nIGluIHRoZSBET00uXG4gKiBAcGFyYW0gZWwgLSBFbGVtZW50IHRvIGZsaXBcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHJlbWFpbihlbCkge1xuICAgIGNvbnN0IG9sZENvb3JkcyA9IGNvb3Jkcy5nZXQoZWwpO1xuICAgIGNvbnN0IG5ld0Nvb3JkcyA9IGdldENvb3JkcyhlbCk7XG4gICAgaWYgKCFpc0VuYWJsZWQoZWwpKVxuICAgICAgICByZXR1cm4gY29vcmRzLnNldChlbCwgbmV3Q29vcmRzKTtcbiAgICBsZXQgYW5pbWF0aW9uO1xuICAgIGlmICghb2xkQ29vcmRzKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcGx1Z2luT3JPcHRpb25zID0gZ2V0T3B0aW9ucyhlbCk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW5Pck9wdGlvbnMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBkZWx0YVggPSBvbGRDb29yZHMubGVmdCAtIG5ld0Nvb3Jkcy5sZWZ0O1xuICAgICAgICBjb25zdCBkZWx0YVkgPSBvbGRDb29yZHMudG9wIC0gbmV3Q29vcmRzLnRvcDtcbiAgICAgICAgY29uc3QgW3dpZHRoRnJvbSwgd2lkdGhUbywgaGVpZ2h0RnJvbSwgaGVpZ2h0VG9dID0gZ2V0VHJhbnNpdGlvblNpemVzKGVsLCBvbGRDb29yZHMsIG5ld0Nvb3Jkcyk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7ZGVsdGFYfXB4LCAke2RlbHRhWX1weClgLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbmQgPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoMCwgMClgLFxuICAgICAgICB9O1xuICAgICAgICBpZiAod2lkdGhGcm9tICE9PSB3aWR0aFRvKSB7XG4gICAgICAgICAgICBzdGFydC53aWR0aCA9IGAke3dpZHRoRnJvbX1weGA7XG4gICAgICAgICAgICBlbmQud2lkdGggPSBgJHt3aWR0aFRvfXB4YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0RnJvbSAhPT0gaGVpZ2h0VG8pIHtcbiAgICAgICAgICAgIHN0YXJ0LmhlaWdodCA9IGAke2hlaWdodEZyb219cHhgO1xuICAgICAgICAgICAgZW5kLmhlaWdodCA9IGAke2hlaWdodFRvfXB4YDtcbiAgICAgICAgfVxuICAgICAgICBhbmltYXRpb24gPSBlbC5hbmltYXRlKFtzdGFydCwgZW5kXSwge1xuICAgICAgICAgICAgZHVyYXRpb246IHBsdWdpbk9yT3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogcGx1Z2luT3JPcHRpb25zLmVhc2luZyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBba2V5ZnJhbWVzXSA9IGdldFBsdWdpblR1cGxlKHBsdWdpbk9yT3B0aW9ucyhlbCwgXCJyZW1haW5cIiwgb2xkQ29vcmRzLCBuZXdDb29yZHMpKTtcbiAgICAgICAgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihrZXlmcmFtZXMpO1xuICAgICAgICBhbmltYXRpb24ucGxheSgpO1xuICAgIH1cbiAgICBhbmltYXRpb25zLnNldChlbCwgYW5pbWF0aW9uKTtcbiAgICBjb29yZHMuc2V0KGVsLCBuZXdDb29yZHMpO1xuICAgIGFuaW1hdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiZmluaXNoXCIsIHVwZGF0ZVBvcy5iaW5kKG51bGwsIGVsKSk7XG59XG4vKipcbiAqIEFkZHMgdGhlIGVsZW1lbnQgd2l0aCBhIHRyYW5zaXRpb24uXG4gKiBAcGFyYW0gZWwgLSBBbmltYXRlcyB0aGUgZWxlbWVudCBiZWluZyBhZGRlZC5cbiAqL1xuZnVuY3Rpb24gYWRkKGVsKSB7XG4gICAgaWYgKE5FVyBpbiBlbClcbiAgICAgICAgZGVsZXRlIGVsW05FV107XG4gICAgY29uc3QgbmV3Q29vcmRzID0gZ2V0Q29vcmRzKGVsKTtcbiAgICBjb29yZHMuc2V0KGVsLCBuZXdDb29yZHMpO1xuICAgIGNvbnN0IHBsdWdpbk9yT3B0aW9ucyA9IGdldE9wdGlvbnMoZWwpO1xuICAgIGlmICghaXNFbmFibGVkKGVsKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBhbmltYXRpb247XG4gICAgaWYgKHR5cGVvZiBwbHVnaW5Pck9wdGlvbnMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBhbmltYXRpb24gPSBlbC5hbmltYXRlKFtcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiBcInNjYWxlKC45OClcIiwgb3BhY2l0eTogMCB9LFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IFwic2NhbGUoMC45OClcIiwgb3BhY2l0eTogMCwgb2Zmc2V0OiAwLjUgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiBcInNjYWxlKDEpXCIsIG9wYWNpdHk6IDEgfSxcbiAgICAgICAgXSwge1xuICAgICAgICAgICAgZHVyYXRpb246IHBsdWdpbk9yT3B0aW9ucy5kdXJhdGlvbiAqIDEuNSxcbiAgICAgICAgICAgIGVhc2luZzogXCJlYXNlLWluXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgW2tleWZyYW1lc10gPSBnZXRQbHVnaW5UdXBsZShwbHVnaW5Pck9wdGlvbnMoZWwsIFwiYWRkXCIsIG5ld0Nvb3JkcykpO1xuICAgICAgICBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGtleWZyYW1lcyk7XG4gICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG4gICAgfVxuICAgIGFuaW1hdGlvbnMuc2V0KGVsLCBhbmltYXRpb24pO1xuICAgIGFuaW1hdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiZmluaXNoXCIsIHVwZGF0ZVBvcy5iaW5kKG51bGwsIGVsKSk7XG59XG4vKipcbiAqIENsZWFuIHVwIGFmdGVyIHJlbW92aW5nIGFuIGVsZW1lbnQgZnJvbSB0aGUgZG9tLlxuICogQHBhcmFtIGVsIC0gRWxlbWVudCBiZWluZyByZW1vdmVkXG4gKiBAcGFyYW0gc3R5bGVzIC0gT3B0aW9uYWwgc3R5bGVzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gY2xlYW5VcChlbCwgc3R5bGVzKSB7XG4gICAgdmFyIF9hO1xuICAgIGVsLnJlbW92ZSgpO1xuICAgIGNvb3Jkcy5kZWxldGUoZWwpO1xuICAgIHNpYmxpbmdzLmRlbGV0ZShlbCk7XG4gICAgYW5pbWF0aW9ucy5kZWxldGUoZWwpO1xuICAgIChfYSA9IGludGVyc2VjdGlvbnMuZ2V0KGVsKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKERFTCBpbiBlbClcbiAgICAgICAgICAgIGRlbGV0ZSBlbFtERUxdO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWwsIE5FVywgeyB2YWx1ZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgICAgICBpZiAoc3R5bGVzICYmIGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3R5bGUgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGVbc3R5bGVdID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIDApO1xufVxuLyoqXG4gKiBBbmltYXRlcyB0aGUgcmVtb3ZhbCBvZiBhbiBlbGVtZW50LlxuICogQHBhcmFtIGVsIC0gRWxlbWVudCB0byByZW1vdmVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghc2libGluZ3MuaGFzKGVsKSB8fCAhY29vcmRzLmhhcyhlbCkpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBbcHJldiwgbmV4dF0gPSBzaWJsaW5ncy5nZXQoZWwpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbCwgREVMLCB7IHZhbHVlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gICAgY29uc3QgZmluYWxYID0gd2luZG93LnNjcm9sbFg7XG4gICAgY29uc3QgZmluYWxZID0gd2luZG93LnNjcm9sbFk7XG4gICAgaWYgKG5leHQgJiYgbmV4dC5wYXJlbnROb2RlICYmIG5leHQucGFyZW50Tm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbmV4dCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByZXYgJiYgcHJldi5wYXJlbnROb2RlKSB7XG4gICAgICAgIHByZXYucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoX2EgPSBnZXRUYXJnZXQoZWwpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICBpZiAoIWlzRW5hYmxlZChlbCkpXG4gICAgICAgIHJldHVybiBjbGVhblVwKGVsKTtcbiAgICBjb25zdCBbdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0XSA9IGRlbGV0ZVBvc2l0aW9uKGVsKTtcbiAgICBjb25zdCBvcHRpb25zT3JQbHVnaW4gPSBnZXRPcHRpb25zKGVsKTtcbiAgICBjb25zdCBvbGRDb29yZHMgPSBjb29yZHMuZ2V0KGVsKTtcbiAgICBpZiAoZmluYWxYICE9PSBzY3JvbGxYIHx8IGZpbmFsWSAhPT0gc2Nyb2xsWSkge1xuICAgICAgICBhZGp1c3RTY3JvbGwoZWwsIGZpbmFsWCwgZmluYWxZLCBvcHRpb25zT3JQbHVnaW4pO1xuICAgIH1cbiAgICBsZXQgYW5pbWF0aW9uO1xuICAgIGxldCBzdHlsZVJlc2V0ID0ge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICB0b3A6IGAke3RvcH1weGAsXG4gICAgICAgIGxlZnQ6IGAke2xlZnR9cHhgLFxuICAgICAgICB3aWR0aDogYCR7d2lkdGh9cHhgLFxuICAgICAgICBoZWlnaHQ6IGAke2hlaWdodH1weGAsXG4gICAgICAgIG1hcmdpbjogXCIwXCIsXG4gICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IFwiY2VudGVyXCIsXG4gICAgICAgIHpJbmRleDogXCIxMDBcIixcbiAgICB9O1xuICAgIGlmICghaXNQbHVnaW4ob3B0aW9uc09yUGx1Z2luKSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKGVsLnN0eWxlLCBzdHlsZVJlc2V0KTtcbiAgICAgICAgYW5pbWF0aW9uID0gZWwuYW5pbWF0ZShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDEpXCIsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKC45OClcIixcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSwgeyBkdXJhdGlvbjogb3B0aW9uc09yUGx1Z2luLmR1cmF0aW9uLCBlYXNpbmc6IFwiZWFzZS1vdXRcIiB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IFtrZXlmcmFtZXMsIG9wdGlvbnNdID0gZ2V0UGx1Z2luVHVwbGUob3B0aW9uc09yUGx1Z2luKGVsLCBcInJlbW92ZVwiLCBvbGRDb29yZHMpKTtcbiAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3R5bGVSZXNldCkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHlsZVJlc2V0ID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdHlsZVJlc2V0KSB8fCBzdHlsZVJlc2V0O1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihlbC5zdHlsZSwgc3R5bGVSZXNldCk7XG4gICAgICAgIH1cbiAgICAgICAgYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihrZXlmcmFtZXMpO1xuICAgICAgICBhbmltYXRpb24ucGxheSgpO1xuICAgIH1cbiAgICBhbmltYXRpb25zLnNldChlbCwgYW5pbWF0aW9uKTtcbiAgICBhbmltYXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcImZpbmlzaFwiLCBjbGVhblVwLmJpbmQobnVsbCwgZWwsIHN0eWxlUmVzZXQpKTtcbn1cbi8qKlxuICogSWYgdGhlIGVsZW1lbnQgYmVpbmcgcmVtb3ZlZCBpcyBhdCB0aGUgdmVyeSBib3R0b20gb2YgdGhlIHBhZ2UsIGFuZCB0aGVcbiAqIHRoZSBwYWdlIHdhcyBzY3JvbGxlZCBpbnRvIGEgc3BhY2UgYmVpbmcgXCJtYWRlIGF2YWlsYWJsZVwiIGJ5IHRoZSBlbGVtZW50XG4gKiB0aGF0IHdhcyByZW1vdmVkLCB0aGUgcGFnZSBzY3JvbGwgd2lsbCBoYXZlIGp1bXBlZCB1cCBzb21lIGFtb3VudC4gV2UgbmVlZFxuICogdG8gb2Zmc2V0IHRoZSBqdW1wIGJ5IHRoZSBhbW91bnQgdGhhdCB0aGUgcGFnZSB3YXMgXCJhdXRvbWF0aWNhbGx5XCIgc2Nyb2xsZWRcbiAqIHVwLiBXZSBjYW4gZG8gdGhpcyBieSBjb21wYXJpbmcgdGhlIHNjcm9sbCBwb3NpdGlvbiBiZWZvcmUgYW5kIGFmdGVyIHRoZVxuICogZWxlbWVudCB3YXMgcmVtb3ZlZCwgYW5kIHRoZW4gb2Zmc2V0dGluZyBieSB0aGF0IGFtb3VudC5cbiAqXG4gKiBAcGFyYW0gZWwgLSBUaGUgZWxlbWVudCBiZWluZyBkZWxldGVkXG4gKiBAcGFyYW0gZmluYWxYIC0gVGhlIGZpbmFsIFggc2Nyb2xsIHBvc2l0aW9uXG4gKiBAcGFyYW0gZmluYWxZIC0gVGhlIGZpbmFsIFkgc2Nyb2xsIHBvc2l0aW9uXG4gKiBAcGFyYW0gb3B0aW9uc09yUGx1Z2luIC0gVGhlIG9wdGlvbnMgb3IgcGx1Z2luXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBhZGp1c3RTY3JvbGwoZWwsIGZpbmFsWCwgZmluYWxZLCBvcHRpb25zT3JQbHVnaW4pIHtcbiAgICBjb25zdCBzY3JvbGxEZWx0YVggPSBzY3JvbGxYIC0gZmluYWxYO1xuICAgIGNvbnN0IHNjcm9sbERlbHRhWSA9IHNjcm9sbFkgLSBmaW5hbFk7XG4gICAgY29uc3Qgc2Nyb2xsQmVmb3JlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yO1xuICAgIGNvbnN0IHNjcm9sbEJlaGF2aW9yID0gZ2V0Q29tcHV0ZWRTdHlsZShyb290KS5zY3JvbGxCZWhhdmlvcjtcbiAgICBpZiAoc2Nyb2xsQmVoYXZpb3IgPT09IFwic21vb3RoXCIpIHtcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gXCJhdXRvXCI7XG4gICAgfVxuICAgIHdpbmRvdy5zY3JvbGxUbyh3aW5kb3cuc2Nyb2xsWCArIHNjcm9sbERlbHRhWCwgd2luZG93LnNjcm9sbFkgKyBzY3JvbGxEZWx0YVkpO1xuICAgIGlmICghZWwucGFyZW50RWxlbWVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBhcmVudCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gICAgbGV0IGxhc3RIZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0O1xuICAgIGxldCBsYXN0V2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGg7XG4gICAgY29uc3Qgc3RhcnRTY3JvbGwgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAvLyBIZXJlIHdlIHVzZSBhIG1hbnVhbCBzY3JvbGwgYW5pbWF0aW9uIHRvIGtlZXAgdGhlIGVsZW1lbnQgdXNpbmcgdGhlIHNhbWVcbiAgICAvLyBlYXNpbmcgYW5kIHRpbWluZyBhcyB0aGUgcGFyZW504oCZcyBzY3JvbGwgYW5pbWF0aW9uLlxuICAgIGZ1bmN0aW9uIHNtb290aFNjcm9sbCgpIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNQbHVnaW4ob3B0aW9uc09yUGx1Z2luKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhWSA9IGxhc3RIZWlnaHQgLSBwYXJlbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhWCA9IGxhc3RXaWR0aCAtIHBhcmVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRTY3JvbGwgKyBvcHRpb25zT3JQbHVnaW4uZHVyYXRpb24gPiBwZXJmb3JtYW5jZS5ub3coKSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogd2luZG93LnNjcm9sbFggLSBkZWx0YVgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHdpbmRvdy5zY3JvbGxZIC0gZGVsdGFZLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RXaWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgc21vb3RoU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBzY3JvbGxCZWZvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc21vb3RoU2Nyb2xsKCk7XG59XG4vKipcbiAqIERldGVybWluZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50IGJlaW5nIHJlbW92ZWQuXG4gKiBAcGFyYW0gZWwgLSBUaGUgZWxlbWVudCBiZWluZyBkZWxldGVkXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBkZWxldGVQb3NpdGlvbihlbCkge1xuICAgIGNvbnN0IG9sZENvb3JkcyA9IGNvb3Jkcy5nZXQoZWwpO1xuICAgIGNvbnN0IFt3aWR0aCwgLCBoZWlnaHRdID0gZ2V0VHJhbnNpdGlvblNpemVzKGVsLCBvbGRDb29yZHMsIGdldENvb3JkcyhlbCkpO1xuICAgIGxldCBvZmZzZXRQYXJlbnQgPSBlbC5wYXJlbnRFbGVtZW50O1xuICAgIHdoaWxlIChvZmZzZXRQYXJlbnQgJiZcbiAgICAgICAgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiB8fFxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50IGluc3RhbmNlb2YgSFRNTEJvZHlFbGVtZW50KSkge1xuICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgaWYgKCFvZmZzZXRQYXJlbnQpXG4gICAgICAgIG9mZnNldFBhcmVudCA9IGRvY3VtZW50LmJvZHk7XG4gICAgY29uc3QgcGFyZW50U3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpO1xuICAgIGNvbnN0IHBhcmVudENvb3JkcyA9IGNvb3Jkcy5nZXQob2Zmc2V0UGFyZW50KSB8fCBnZXRDb29yZHMob2Zmc2V0UGFyZW50KTtcbiAgICBjb25zdCB0b3AgPSBNYXRoLnJvdW5kKG9sZENvb3Jkcy50b3AgLSBwYXJlbnRDb29yZHMudG9wKSAtXG4gICAgICAgIHJhdyhwYXJlbnRTdHlsZXMuYm9yZGVyVG9wV2lkdGgpO1xuICAgIGNvbnN0IGxlZnQgPSBNYXRoLnJvdW5kKG9sZENvb3Jkcy5sZWZ0IC0gcGFyZW50Q29vcmRzLmxlZnQpIC1cbiAgICAgICAgcmF3KHBhcmVudFN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgpO1xuICAgIHJldHVybiBbdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0XTtcbn1cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGF1dG9tYXRpY2FsbHkgYWRkcyBhbmltYXRpb24gZWZmZWN0cyB0byBpdHNlbGYgYW5kIGl0c1xuICogaW1tZWRpYXRlIGNoaWxkcmVuLiBTcGVjaWZpY2FsbHkgaXQgYWRkcyBlZmZlY3RzIGZvciBhZGRpbmcsIG1vdmluZywgYW5kXG4gKiByZW1vdmluZyBET00gZWxlbWVudHMuXG4gKiBAcGFyYW0gZWwgLSBBIHBhcmVudCBlbGVtZW50IHRvIGFkZCBhbmltYXRpb25zIHRvLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25hbCBvYmplY3Qgb2Ygb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gYXV0b0FuaW1hdGUoZWwsIGNvbmZpZyA9IHt9KSB7XG4gICAgaWYgKG11dGF0aW9ucyAmJiByZXNpemUpIHtcbiAgICAgICAgY29uc3QgbWVkaWFRdWVyeSA9IHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIik7XG4gICAgICAgIGNvbnN0IGlzRGlzYWJsZWREdWVUb1JlZHVjZU1vdGlvbiA9IG1lZGlhUXVlcnkubWF0Y2hlcyAmJlxuICAgICAgICAgICAgIWlzUGx1Z2luKGNvbmZpZykgJiZcbiAgICAgICAgICAgICFjb25maWcuZGlzcmVzcGVjdFVzZXJNb3Rpb25QcmVmZXJlbmNlO1xuICAgICAgICBpZiAoIWlzRGlzYWJsZWREdWVUb1JlZHVjZU1vdGlvbikge1xuICAgICAgICAgICAgZW5hYmxlZC5hZGQoZWwpO1xuICAgICAgICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUoZWwpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihlbC5zdHlsZSwgeyBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yRWFjaChlbCwgdXBkYXRlUG9zLCBwb2xsLCAoZWxlbWVudCkgPT4gcmVzaXplID09PSBudWxsIHx8IHJlc2l6ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzaXplLm9ic2VydmUoZWxlbWVudCkpO1xuICAgICAgICAgICAgaWYgKGlzUGx1Z2luKGNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNldChlbCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2V0KGVsLCB7IGR1cmF0aW9uOiAyNTAsIGVhc2luZzogXCJlYXNlLWluLW91dFwiLCAuLi5jb25maWcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdXRhdGlvbnMub2JzZXJ2ZShlbCwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICAgICAgICBwYXJlbnRzLmFkZChlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICBwYXJlbnQ6IGVsLFxuICAgICAgICBlbmFibGU6ICgpID0+IHtcbiAgICAgICAgICAgIGVuYWJsZWQuYWRkKGVsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzYWJsZTogKCkgPT4ge1xuICAgICAgICAgICAgZW5hYmxlZC5kZWxldGUoZWwpO1xuICAgICAgICB9LFxuICAgICAgICBpc0VuYWJsZWQ6ICgpID0+IGVuYWJsZWQuaGFzKGVsKSxcbiAgICB9KTtcbn1cbi8qKlxuICogVGhlIHZ1ZSBkaXJlY3RpdmUuXG4gKi9cbmNvbnN0IHZBdXRvQW5pbWF0ZSA9IHtcbiAgICBtb3VudGVkOiAoZWwsIGJpbmRpbmcpID0+IHtcbiAgICAgICAgYXV0b0FuaW1hdGUoZWwsIGJpbmRpbmcudmFsdWUgfHwge30pO1xuICAgIH0sXG4gICAgLy8gaWdub3JlIHNzciBzZWUgIzk2OlxuICAgIGdldFNTUlByb3BzOiAoKSA9PiAoe30pLFxufTtcblxuZXhwb3J0IHsgYXV0b0FuaW1hdGUgYXMgZGVmYXVsdCwgZ2V0VHJhbnNpdGlvblNpemVzLCB2QXV0b0FuaW1hdGUgfTtcbiJdLCJuYW1lcyI6WyJwYXJlbnRzIiwiU2V0IiwiY29vcmRzIiwiV2Vha01hcCIsInNpYmxpbmdzIiwiYW5pbWF0aW9ucyIsImludGVyc2VjdGlvbnMiLCJpbnRlcnZhbHMiLCJvcHRpb25zIiwiZGVib3VuY2VzIiwiZW5hYmxlZCIsIldlYWtTZXQiLCJyb290Iiwic2Nyb2xsWCIsInNjcm9sbFkiLCJUR1QiLCJERUwiLCJORVciLCJoYW5kbGVNdXRhdGlvbnMiLCJtdXRhdGlvbnMiLCJlbGVtZW50cyIsImdldEVsZW1lbnRzIiwiZm9yRWFjaCIsImVsIiwiYW5pbWF0ZSIsImhhbmRsZVJlc2l6ZXMiLCJlbnRyaWVzIiwiZW50cnkiLCJ0YXJnZXQiLCJ1cGRhdGVBbGxQb3MiLCJoYXMiLCJ1cGRhdGVQb3MiLCJvYnNlcnZlUG9zaXRpb24iLCJvbGRPYnNlcnZlciIsImdldCIsImRpc2Nvbm5lY3QiLCJyZWN0IiwiaW52b2NhdGlvbnMiLCJidWZmZXIiLCJnZXRDb29yZHMiLCJzZXQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsInJvb3RNYXJnaW5zIiwidG9wIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0Iiwicm9vdE1hcmdpbiIsIm1hcCIsInB4IiwiTWF0aCIsImZsb29yIiwiam9pbiIsIm9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJ0aHJlc2hvbGQiLCJvYnNlcnZlIiwiY2xlYXJUaW1lb3V0Iiwib3B0aW9uc09yUGx1Z2luIiwiZ2V0T3B0aW9ucyIsImRlbGF5IiwiaXNQbHVnaW4iLCJkdXJhdGlvbiIsInNldFRpbWVvdXQiLCJjdXJyZW50QW5pbWF0aW9uIiwiZmluaXNoZWQiLCJwYXJlbnQiLCJsb3dQcmlvcml0eSIsInBvbGwiLCJzZXRJbnRlcnZhbCIsImJpbmQiLCJyb3VuZCIsInJhbmRvbSIsImNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJlc2l6ZSIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiTXV0YXRpb25PYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9ic2VydmVkTm9kZXMiLCJyZWR1Y2UiLCJub2RlcyIsIm11dGF0aW9uIiwiQXJyYXkiLCJmcm9tIiwiYWRkZWROb2RlcyIsInJlbW92ZWROb2RlcyIsIm9ubHlDb21tZW50Tm9kZXNPYnNlcnZlZCIsImV2ZXJ5Iiwibm9kZSIsIm5vZGVOYW1lIiwiRWxlbWVudCIsImFkZCIsImkiLCJjaGlsZHJlbiIsImxlbmd0aCIsImNoaWxkIiwiaXRlbSIsInByZXZpb3VzU2libGluZyIsIm5leHRTaWJsaW5nIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIl9hIiwiaXNNb3VudGVkIiwiaXNDb25uZWN0ZWQiLCJwcmVFeGlzdGluZyIsImRlbGV0ZSIsImNhbmNlbCIsInJlbWFpbiIsInJlbW92ZSIsInJhdyIsInN0ciIsIk51bWJlciIsInJlcGxhY2UiLCJnZXRTY3JvbGxPZmZzZXQiLCJwIiwicGFyZW50RWxlbWVudCIsInNjcm9sbExlZnQiLCJzY3JvbGxUb3AiLCJ4IiwieSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImdldFRyYW5zaXRpb25TaXplcyIsIm9sZENvb3JkcyIsIm5ld0Nvb3JkcyIsIndpZHRoRnJvbSIsImhlaWdodEZyb20iLCJ3aWR0aFRvIiwiaGVpZ2h0VG8iLCJzdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwic2l6aW5nIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInBhZGRpbmdZIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckJvdHRvbVdpZHRoIiwicGFkZGluZ1giLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImJvcmRlclJpZ2h0V2lkdGgiLCJib3JkZXJMZWZ0V2lkdGgiLCJlYXNpbmciLCJnZXRUYXJnZXQiLCJ1bmRlZmluZWQiLCJpc0VuYWJsZWQiLCJjYWxsYmFja3MiLCJnZXRQbHVnaW5UdXBsZSIsInBsdWdpblJldHVybiIsImlzQXJyYXkiLCJjb25maWciLCJhbmltYXRpb24iLCJwbHVnaW5Pck9wdGlvbnMiLCJkZWx0YVgiLCJkZWx0YVkiLCJzdGFydCIsInRyYW5zZm9ybSIsImVuZCIsImtleWZyYW1lcyIsIkFuaW1hdGlvbiIsInBsYXkiLCJvcGFjaXR5Iiwib2Zmc2V0IiwiY2xlYW5VcCIsImNvbmZpZ3VyYWJsZSIsIkhUTUxFbGVtZW50Iiwic3R5bGUiLCJwcmV2IiwibmV4dCIsImZpbmFsWCIsImZpbmFsWSIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJhcHBlbmRDaGlsZCIsImRlbGV0ZVBvc2l0aW9uIiwiYWRqdXN0U2Nyb2xsIiwic3R5bGVSZXNldCIsInBvc2l0aW9uIiwibWFyZ2luIiwicG9pbnRlckV2ZW50cyIsInRyYW5zZm9ybU9yaWdpbiIsInpJbmRleCIsImFzc2lnbiIsInNjcm9sbERlbHRhWCIsInNjcm9sbERlbHRhWSIsInNjcm9sbEJlZm9yZSIsInNjcm9sbEJlaGF2aW9yIiwic2Nyb2xsVG8iLCJsYXN0SGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwibGFzdFdpZHRoIiwiY2xpZW50V2lkdGgiLCJzdGFydFNjcm9sbCIsInBlcmZvcm1hbmNlIiwibm93Iiwic21vb3RoU2Nyb2xsIiwib2Zmc2V0UGFyZW50IiwiSFRNTEJvZHlFbGVtZW50IiwiYm9keSIsInBhcmVudFN0eWxlcyIsInBhcmVudENvb3JkcyIsImF1dG9BbmltYXRlIiwibWVkaWFRdWVyeSIsIm1hdGNoTWVkaWEiLCJpc0Rpc2FibGVkRHVlVG9SZWR1Y2VNb3Rpb24iLCJtYXRjaGVzIiwiZGlzcmVzcGVjdFVzZXJNb3Rpb25QcmVmZXJlbmNlIiwiZWxlbWVudCIsImNoaWxkTGlzdCIsImZyZWV6ZSIsImVuYWJsZSIsImRpc2FibGUiLCJ2QXV0b0FuaW1hdGUiLCJtb3VudGVkIiwiYmluZGluZyIsImdldFNTUlByb3BzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@formkit/auto-animate/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@formkit/auto-animate/react/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@formkit/auto-animate/react/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAutoAnimate: () => (/* binding */ useAutoAnimate)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _index_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.mjs */ \"(ssr)/./node_modules/@formkit/auto-animate/index.mjs\");\n\n\n/**\n * AutoAnimate hook for adding dead-simple transitions and animations to react.\n * @param options - Auto animate options or a plugin\n * @returns\n */ function useAutoAnimate(options) {\n    const [controller, setController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const memoizedOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>options, []);\n    const element = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((node)=>{\n        if (node instanceof HTMLElement) {\n            setController((0,_index_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(node, memoizedOptions));\n        } else {\n            setController(undefined);\n        }\n    }, [\n        memoizedOptions\n    ]);\n    const setEnabled = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((enabled)=>{\n        if (controller) {\n            enabled ? controller.enable() : controller.disable();\n        }\n    }, [\n        controller\n    ]);\n    return [\n        element,\n        setEnabled\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvYXV0by1hbmltYXRlL3JlYWN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBdUQ7QUFDaEI7QUFFdkM7Ozs7Q0FJQyxHQUNELFNBQVNJLGVBQWVDLE9BQU87SUFDM0IsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUdQLCtDQUFRQTtJQUM1QyxNQUFNUSxrQkFBa0JQLDhDQUFPQSxDQUFDLElBQU1JLFNBQVMsRUFBRTtJQUNqRCxNQUFNSSxVQUFVUCxrREFBV0EsQ0FBQyxDQUFDUTtRQUN6QixJQUFJQSxnQkFBZ0JDLGFBQWE7WUFDN0JKLGNBQWNKLHNEQUFXQSxDQUFDTyxNQUFNRjtRQUNwQyxPQUNLO1lBQ0RELGNBQWNLO1FBQ2xCO0lBQ0osR0FBRztRQUFDSjtLQUFnQjtJQUNwQixNQUFNSyxhQUFhWCxrREFBV0EsQ0FBQyxDQUFDWTtRQUM1QixJQUFJUixZQUFZO1lBQ1pRLFVBQVVSLFdBQVdTLE1BQU0sS0FBS1QsV0FBV1UsT0FBTztRQUN0RDtJQUNKLEdBQUc7UUFBQ1Y7S0FBVztJQUNmLE9BQU87UUFBQ0c7UUFBU0k7S0FBVztBQUNoQztBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RvZG8vLi9ub2RlX21vZHVsZXMvQGZvcm1raXQvYXV0by1hbmltYXRlL3JlYWN0L2luZGV4Lm1qcz8zNTQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VNZW1vLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBhdXRvQW5pbWF0ZSBmcm9tICcuLi9pbmRleC5tanMnO1xuXG4vKipcbiAqIEF1dG9BbmltYXRlIGhvb2sgZm9yIGFkZGluZyBkZWFkLXNpbXBsZSB0cmFuc2l0aW9ucyBhbmQgYW5pbWF0aW9ucyB0byByZWFjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQXV0byBhbmltYXRlIG9wdGlvbnMgb3IgYSBwbHVnaW5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHVzZUF1dG9BbmltYXRlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBbY29udHJvbGxlciwgc2V0Q29udHJvbGxlcl0gPSB1c2VTdGF0ZSgpO1xuICAgIGNvbnN0IG1lbW9pemVkT3B0aW9ucyA9IHVzZU1lbW8oKCkgPT4gb3B0aW9ucywgW10pO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1c2VDYWxsYmFjaygobm9kZSkgPT4ge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBzZXRDb250cm9sbGVyKGF1dG9BbmltYXRlKG5vZGUsIG1lbW9pemVkT3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0Q29udHJvbGxlcih1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfSwgW21lbW9pemVkT3B0aW9uc10pO1xuICAgIGNvbnN0IHNldEVuYWJsZWQgPSB1c2VDYWxsYmFjaygoZW5hYmxlZCkgPT4ge1xuICAgICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgZW5hYmxlZCA/IGNvbnRyb2xsZXIuZW5hYmxlKCkgOiBjb250cm9sbGVyLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sbGVyXSk7XG4gICAgcmV0dXJuIFtlbGVtZW50LCBzZXRFbmFibGVkXTtcbn1cblxuZXhwb3J0IHsgdXNlQXV0b0FuaW1hdGUgfTtcbiJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsImF1dG9BbmltYXRlIiwidXNlQXV0b0FuaW1hdGUiLCJvcHRpb25zIiwiY29udHJvbGxlciIsInNldENvbnRyb2xsZXIiLCJtZW1vaXplZE9wdGlvbnMiLCJlbGVtZW50Iiwibm9kZSIsIkhUTUxFbGVtZW50IiwidW5kZWZpbmVkIiwic2V0RW5hYmxlZCIsImVuYWJsZWQiLCJlbmFibGUiLCJkaXNhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@formkit/auto-animate/react/index.mjs\n");

/***/ })

};
;